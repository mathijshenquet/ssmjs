// Generated by CoffeeScript 2.7.0
(function() {
  var HP, MP, MemoryBank, PC, RR, SP, binOp, binPred, global;

  if (typeof global === "undefined" || global === null) {
    global = window;
  }

  binOp = function(op) {
    var fn, lbl;
    fn = new Function("a, b", `return a ${op} b`);
    lbl = new Function("a, b", `return '('+a+' ${op} '+b+')';`);
    return function(newLabel) {
      var a, b, label, value;
      b = this.pop();
      a = this.pop();
      value = fn(a.value, b.value);
      label = (a.label != null) && (b.label != null) && (newLabel == null) ? lbl(a.label, b.label) : void 0;
      return this.push(value, newLabel != null ? newLabel : label);
    };
  };

  binPred = function(op) {
    var fn, lbl;
    fn = new Function("a, b", `return (a ${op} b) ? 1 : -1`);
    lbl = new Function("a, b", `return '('+a+' ${op} '+b+')';`);
    return function(newLabel) {
      var a, b, label, value;
      b = this.pop();
      a = this.pop();
      value = fn(a.value, b.value);
      label = (a.label != null) && (b.label != null) && (newLabel == null) ? lbl(a.label, b.label) : void 0;
      return this.push(value, newLabel != null ? newLabel : label);
    };
  };

  global.SSMInstructionSet = {
    add: binOp("+"),
    sub: binOp("-"),
    mul: binOp("*"),
    div: binOp("/"),
    mod: binOp("%"),
    neg: function(newLabel) {
      var label, value;
      ({value, label} = this.pop());
      return this.push(-value, `-(${newLabel != null ? newLabel : label})`);
    },
    eq: binPred("=="),
    ne: binPred("!="),
    lt: binPred("<"),
    gt: binPred(">"),
    le: binPred("<="),
    ge: binPred(">="),
    or: binOp("|"),
    xor: binOp("^"),
    not: function(newLabel) {
      var label, value;
      ({value, label} = this.pop());
      return this.push(value ^ 0xFFFF, `!(${newLabel != null ? newLabel : a.label})`);
    },
    ldc: function(a, label) {
      return this.push(a, label != null ? label : a);
    },
    ldr: function(regHandle, label) {
      var id;
      id = this.regId(regHandle);
      return this.push(this.get(id), label != null ? label : this.get(id, 'label'));
    },
    str: function(regHandle, newLabel) {
      var label, value;
      ({value, label} = this.pop());
      return this.set(this.regId(regHandle), value, newLabel != null ? newLabel : label);
    },
    lds: function(n, label) {
      var addr;
      addr = this.r[SP] + n;
      this.push(this.read(addr), label != null ? label : this.read(addr, 'label'));
      return this.mem.read[addr] = true;
    },
    sts: function(n, newLabel) {
      var label, value;
      ({value, label} = this.pop());
      return this.write(this.get(SP) + (n + 1), value, newLabel != null ? newLabel : label);
    },
    ldl: function(n, newLabel) {
      return this.push(this.read(this.get(MP) + n), newLabel != null ? newLabel : this.read(this.get(MP) + n, 'label'));
    },
    stl: function(n, newLabel) {
      var label, value;
      ({value, label} = this.pop());
      return this.write(this.get(MP) + n, value, newLabel != null ? newLabel : label);
    },
    brt: function(addr) {
      if (this.pop().value === 1) {
        return this.jump(addr);
      }
    },
    brf: function(addr) {
      if (this.pop().value !== 1) {
        return this.jump(addr);
      }
    },
    bra: function(addr) {
      return this.jump(addr);
    },
    bsr: function(addr) {
      this.push(this.get(PC), "PC return");
      return this.jump(addr);
    },
    link: function(n) {
      var j, ref, results;
      this.push(this.get(MP), "MP return");
      this.set(MP, this.get(SP));
      results = [];
      for (j = 0, ref = n; (0 <= ref ? j < ref : j > ref); 0 <= ref ? j++ : j--) {
        results.push(this.push(0));
      }
      return results;
    },
    unlink: function() {
      this.set(SP, this.get(MP));
      return this.set(MP, this.pop().value);
    },
    ret: function(addr) {
      return this.set(PC, this.pop().value);
    },
    ajs: function(n) {
      return this.set(SP, this.get(SP) + n);
    },
    halt: function() {
      return this.halted = true;
    },
    annote: function(regHandle, low, high, color, text) {
      var i, j, ref, ref1, reg, results;
      console.log(regHandle);
      reg = this.regId(regHandle);
      console.log(this.r[reg], low, high, color, text);
      results = [];
      for (i = j = ref = this.r[reg] + low, ref1 = this.r[reg] + high; (ref <= ref1 ? j <= ref1 : j >= ref1); i = ref <= ref1 ? ++j : --j) {
        console.log(i);
        results.push(this.mem.annote[i] = {color, text});
      }
      return results;
    },
    nop: function() {},
    trap: function(n) {
      return [
        (() => {
          return View.print(this.peek());
        })
      ][n]();
    }
  };

  PC = 0;

  SP = 1;

  MP = 2;

  HP = 3;

  RR = 4;

  MemoryBank = class MemoryBank {
    constructor(length) {
      var buffer;
      this.buffer = buffer = new ArrayBuffer(length);
      this.f64 = new Float64Array(buffer);
      this.u32 = new Uint32Array(buffer);
      this.i32 = new Int32Array(buffer);
      this.f32 = new Float32Array(buffer);
      this.u16 = new Uint16Array(buffer);
      this.i16 = new Int16Array(buffer);
      this.u8 = new Uint8Array(buffer);
      this.i8 = new Int8Array(buffer);
      this.annote = {};
      this.label = {};
      this.written = {};
      this.read = {};
      this.raw = this.u32;
      this.int = this.i32;
      this.float = this.f32;
    }

  };

  global.SimpleCPU = class SimpleCPU {
    constructor(instructions) {
      this.instructions = instructions;
      this.code = [];
      this.labels = {};
      this.reset();
    }

    reset() {
      var ref, ref1;
      this.history = [];
      this.memSize = 1024;
      this.memSeen = -1;
      this.mem = new MemoryBank(4 * this.memSize);
      this.regCount = 8;
      this.reg = new MemoryBank(4 * this.regCount);
      this.r = this.reg.int;
      this.r[PC] = 0;
      this.r[SP] = -1;
      this.r[MP] = -1;
      this.r[HP] = -1;
      this.halted = false;
      return this.lineNr = (ref = (ref1 = this.code[this.r[PC]]) != null ? ref1.lineNr : void 0) != null ? ref : false;
    }

    write(addr, value, label) {
      var oldLabel, oldValue, oldWritten;
      oldValue = this.mem.int[addr];
      oldLabel = this.mem.label[addr];
      oldWritten = this.mem.written[addr];
      return this.stateApply({
        do: function() {
          this.mem.int[addr] = value;
          this.mem.written[addr] = true;
          if (label != null) {
            return this.mem.label[addr] = label;
          }
        },
        undo: function() {
          this.mem.int[addr] = oldValue;
          this.mem.written[addr] = oldWritten;
          return this.mem.label[addr] = oldLabel;
        }
      });
    }

    read(addr, type) {
      return this.stateApply({
        do: function() {
          this.mem.read[addr] = true;
          return this.mem[type != null ? type : 'int'][addr];
        },
        undo: function() {}
      });
    }

    set(n, value, label) {
      var oldLabel, oldValue, oldWritten;
      oldValue = this.reg.int[n];
      oldLabel = this.reg.label[n];
      oldWritten = this.reg.written[n];
      return this.stateApply({
        do: function() {
          this.reg.int[n] = value;
          this.reg.written[n] = true;
          if (label != null) {
            return this.reg.label[n] = label;
          }
        },
        undo: function() {
          this.reg.int[n] = oldValue;
          this.reg.written[n] = oldWritten;
          return this.reg.label[n] = oldLabel;
        }
      });
    }

    get(n, type) {
      return this.stateApply({
        do: function() {
          this.reg.read[n] = true;
          return this.reg[type != null ? type : 'int'][n];
        },
        undo: function() {}
      });
    }

    jump(addr) {
      var oldLineNr, oldPC;
      oldPC = this.r[PC];
      oldLineNr = this.lineNr;
      return this.stateApply({
        do: function() {
          var ref, ref1;
          this.r[PC] = this.labels[addr];
          return this.lineNr = (ref = (ref1 = this.code[this.r[PC]]) != null ? ref1.lineNr : void 0) != null ? ref : false;
        },
        undo: function() {
          this.r[PC] = oldPC;
          return this.lineNr = oldLineNr;
        }
      });
    }

    pop() {
      return this.stateApply({
        do: function() {
          return {
            value: this.read(this.r[SP]),
            label: this.mem.label[this.r[SP]--]
          };
        },
        undo: function() {
          return this.r[SP]++;
        }
      });
    }

    push(value, label) {
      var oldMemSeen;
      oldMemSeen = this.memSeen;
      return this.stateApply({
        do: function() {
          this.write(++this.r[SP], value, label);
          return this.memSeen = Math.max(this.memSeen, this.r[SP]);
        },
        undo: function() {
          this.r[SP]--;
          return this.memSeen = oldMemSeen;
        }
      });
    }

    peek() {
      return this.stateApply({
        do: function() {
          return this.read(this.r[SP]);
        },
        undo: function() {}
      });
    }

    regId(handle) {
      var ref;
      return (ref = {
        pc: PC,
        sp: SP,
        mp: MP,
        hp: HP,
        rr: RR
      }[(new String(handle)).toLowerCase()]) != null ? ref : handle;
    }

    regName(id) {
      var ref;
      return (ref = ["pc", "sp", "mp", "hp", "rr"][id]) != null ? ref.toUpperCase() : void 0;
    }

    regVal(selector) {
      var id;
      if (+selector === selector) {
        id = selector;
      } else {
        id = this.regId(selector);
      }
      return this.r[id];
    }

    stateApply(cmd) {
      this.stepObject.stateActions.push(cmd);
      return cmd.do.call(this);
    }

    load(code) {
      var addr, instruction, j, len, ref, ref1, results;
      this.code = code;
      this.lineNr = (ref = this.code[this.r[PC]]) != null ? ref.lineNr : void 0;
      this.labels = {};
      addr = 0;
      ref1 = this.code;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        instruction = ref1[j];
        if (instruction.label) {
          this.labels[instruction.label] = addr;
        }
        results.push(addr++);
      }
      return results;
    }

    run() {
      while (this.step() === true) {
        continue;
      }
      this.mem.read = {};
      this.mem.written = {};
      this.reg.read = {};
      this.reg.written = {};
      return true;
    }

    step() {
      var instruction, ref;
      if (this.halted) {
        return false;
      }
      this.stepObject = {
        oldPC: this.r[PC],
        stateActions: []
      };
      instruction = this.code[this.r[PC]++];
      if (instruction == null) {
        this.lineNr = false;
        this.r[PC]--;
        return false;
      }
      this.exec(instruction);
      this.history.push(this.stepObject);
      this.lineNr = (ref = this.code[this.r[PC]]) != null ? ref.lineNr : void 0;
      return true;
    }

    undo() {
      var action, ref, stepObject;
      if (!(stepObject = this.history.pop())) {
        return;
      }
      while (action = stepObject.stateActions.pop()) {
        action.undo.call(this);
      }
      this.r[PC] = stepObject.oldPC;
      return this.lineNr = (ref = this.code[this.r[PC]]) != null ? ref.lineNr : void 0;
    }

    exec(instruction) {
      var args;
      if (this.instructions[instruction.opcode] == null) {
        throw new Error(`Unknown opcode ${instruction.opcode}`);
      }
      args = [].concat(instruction.args, instruction.hint.label);
      this.instructions[instruction.opcode].apply(this, args);
    }

  };

}).call(this);

//# sourceMappingURL=cpu.js.map
