// Generated by CoffeeScript 2.7.0
(function() {
  var global;

  if (typeof global === "undefined" || global === null) {
    global = window;
  }

  $("#src").keyup(function(e) {
    return setTimeout(View.sourceChanged, 50);
  });

  $(document).delegate('#src', 'keydown', function(e) {
    var keyCode, node, range, sel;
    keyCode = e.keyCode || e.which;
    if (keyCode === 9) {
      e.preventDefault();
      if (window.getSelection) {
        sel = window.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          range = sel.getRangeAt(0);
          range.deleteContents();
          node = document.createTextNode("\t");
          range.insertNode(node);
          return sel.collapse(node, 1);
        }
      } else if (document.selection && document.selection.createRange) {
        range = document.selection.createRange();
        range.pasteHTML("\t");
        range.move("character", 1);
        return range.select();
      }
    }
  });

  String.prototype.padl = function(str, len) {
    var padding;
    padding = Array(((len / str.length) | 0) + 1).join(str);
    return padding.substring(0, padding.length - this.length) + this;
  };

  String.prototype.divide = function(len) {
    var i, out, pieces;
    pieces = Math.ceil(this.length / len);
    out = [];
    i = 0;
    while (i < pieces) {
      out.push(this.slice(i * len, (i + 1) * len));
      i++;
    }
    return out;
  };

  Number.prototype.showHex = function() {};

  Number.prototype.showBinary = function() {
    return (this.valueOf() === 0 ? "" : this.toString(2)).padl("-", 32).divide(4).join(" ");
  };

  global.View = {
    addButton: function(name, fn) {
      var $btn;
      $btn = $(`<button class=ctrl_btn id=btn_${name}><img src='./static/img/${name}.png' /></button>`);
      $("#ctrl").append($btn);
      return $btn.click(fn);
    },
    showPC: function(nr) {
      var $pc;
      $pc = $("#pc");
      if (nr === false) {
        return $pc.hide();
      } else {
        return $pc.animate({
          top: `${(nr * 20) + 8}px`
        }, 200).show();
      }
    },
    getSrc: function() {
      return $("#src")[0].textContent;
    },
    print: function(thing) {
      var $out;
      console.log(thing);
      $out = $("#console-out");
      $out.append(thing).append("<hr />");
      return $out[0].scrollTop = $out[0].scrollHeight;
    },
    update: function(cpu) {
      this.showPC(cpu.lineNr);
      this.showMem(cpu, ["hex", "int", "annotation", "binary"]);
      return this.showRegs(cpu, ["hex", "int", "annotation", "binary"]);
    },
    showChar: function(cp) {
      if (cp < 32) {
        switch (cp) {
          case 0:
            return void 0;
          case 10:
            return "\\n";
          case 13:
            return "\\r";
          case 9:
            return "\\t";
          default:
            return `\\${cp}`;
        }
      } else {
        return String.fromCharCode(cp);
      }
    },
    memoryViews: {
      hex: function(bank, addr) {
        var nr;
        nr = bank.raw[addr];
        return (nr === 0 ? "" : nr.toString(16)).padl("-", 8).divide(2).join(" ");
      },
      binary: function(bank, addr) {
        var nr;
        nr = bank.raw[addr];
        return (nr === 0 ? "" : nr.toString(2)).padl("-", 32).divide(4).join(" ");
      },
      int: function(bank, addr) {
        return bank.int[addr];
      },
      float: function(bank, addr) {
        return bank.float[addr];
      },
      label: function(bank, addr) {
        var ref;
        return (ref = bank.label[addr]) != null ? ref : "";
      },
      annotation: function(bank, addr) {
        var ref, ref1, ref2, ref3, ref4;
        return `<span style=color:${(ref = (ref1 = bank.annote[addr]) != null ? ref1.color : void 0) != null ? ref : "inherit"};>${(ref2 = (ref3 = (ref4 = bank.annote[addr]) != null ? ref4.text : void 0) != null ? ref3 : bank.label[addr]) != null ? ref2 : ""}</span>`;
      },
      char: function(bank, addr) {
        var ref, ref1;
        return `${(ref = this.showChar(bank.u16[addr * 2 + 1])) != null ? ref : ""}${(ref1 = this.showChar(bank.u16[addr * 2])) != null ? ref1 : "\\0"}`;
      }
    },
    memoryBankRow: function(bank, addr, rows, reg_name) {
      var $row, annotation, j, len1, ref, ref1, ref2, row, rowspan;
      console.log(reg_name);
      $row = (reg_name != null ? $(`<tr id='reg_${reg_name.toLowerCase()}' />`) : $("<tr />"));
      for (j = 0, len1 = rows.length; j < len1; j++) {
        row = rows[j];
        rowspan = 1;
        if (row === "annotation") {
          if ((ref = bank.annote[addr]) != null ? ref.ignore : void 0) {
            continue;
          }
          annotation = (ref1 = bank.annote[addr]) != null ? ref1.text : void 0;
          if (annotation != null) {
            while (((ref2 = bank.annote[addr + rowspan]) != null ? ref2.text : void 0) === annotation) {
              bank.annote[addr + rowspan].ignore = true;
              rowspan++;
            }
          }
        }
        $row.append($(`<td rowspan=${rowspan} class='mem_${row} ${rowspan !== 1 ? "mem_rowspan" : ""}'>${this.memoryViews[row](bank, addr)}</td>`));
      }
      return $row;
    },
    showMem: function(cpu, rows) {
      var $row, $tbody, $thead, addr, j, len1, mp, offset, ref, row, sp;
      $tbody = $("#mem .tbody tbody");
      $tbody.empty();
      sp = cpu.regVal("sp");
      mp = cpu.regVal("mp");
      $thead = $("#mem .thead thead tr");
      $thead.empty();
      $thead.append($("<th class='mem_addr'>address</th>"));
      $thead.append($("<th class='mem_mp_offset'></th>"));
      for (j = 0, len1 = rows.length; j < len1; j++) {
        row = rows[j];
        $thead.append($(`<th class='mem_${row}'>${row}</th>`));
      }
      addr = 0;
      while (addr <= cpu.memSeen) {
        $row = this.memoryBankRow(cpu.mem, addr, rows);
        offset = mp !== -1 && (-8 < (ref = addr - mp) && ref < 8) ? addr === mp ? "mp" : addr < mp ? addr - mp : `+${addr - mp}` : "";
        $row.prepend($(`<td class='mem_mp_offset'>${offset}</td>`));
        $row.prepend($(`<td class='mem_addr'>0x${addr.toString(16).padl('0', 8)}</td>`));
        $tbody.append($row);
        if (addr === mp) {
          $row.addClass("mp");
        }
        if (addr > sp) {
          $row.addClass("zombie_mem");
        }
        if (cpu.mem.written[addr]) {
          $row.addClass("ping-write");
        } else if (cpu.mem.read[addr]) {
          $row.addClass("ping-read");
        }
        addr++;
      }
      cpu.mem.written = {};
      return cpu.mem.read = {};
    },
    showRegs: function(cpu, rows) {
      var $row, $tbody, $thead, id, j, len1, reg_name, row;
      $tbody = $("#regs .tbody tbody");
      $tbody.empty();
      $thead = $("#regs .thead thead tr");
      $thead.empty();
      $thead.append($("<th class='mem_addr'>address</th>"));
      for (j = 0, len1 = rows.length; j < len1; j++) {
        row = rows[j];
        $thead.append($(`<th class='mem_${row}'>${row}</th>`));
      }
      id = 0;
      while (id < cpu.regCount) {
        reg_name = cpu.regName(id);
        $row = this.memoryBankRow(cpu.reg, id, rows, reg_name);
        $row.prepend($(`<td class='mem_addr'>${reg_name != null ? reg_name : `R${id}`}</td>`));
        $tbody.append($row);
        if (cpu.reg.written[id]) {
          $row.addClass("ping-write");
        } else if (cpu.reg.read[id]) {
          $row.addClass("ping-read");
        }
        id++;
      }
      cpu.reg.written = {};
      return cpu.reg.read = {};
    },
    sourceChanged: function() {}
  };

}).call(this);

//# sourceMappingURL=view.js.map
