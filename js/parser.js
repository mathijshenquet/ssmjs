// Generated by CoffeeScript 2.7.0
(function() {
  var argMatchers, global, matchArg, matchLabel, matchOpcode, token;

  if (typeof global === "undefined" || global === null) {
    global = window;
  }

  token = function(regex, fn) {
    return function(src) {
      var res;
      if (!(res = regex.exec(src))) {
        return false;
      }
      src = src.slice(res[0].length);
      return [src, fn(res)];
    };
  };

  matchLabel = token(/^([a-zA-Z_\-]+):/, function(match) {
    return match[1];
  });

  matchOpcode = token(/^[a-zA-Z]+/, function(match) {
    return match[0];
  });

  argMatchers = [
    token(/^0x[0-9a-fA-F]+/,
    function(match) {
      return parseInt(match[0]);
    }),
    token(/^0b([01]+)/,
    function(match) {
      return parseInt(match[1],
    2);
    }),
    token(/^-?[0-9]+(\.[0-9]+)?/,
    function(match) {
      return +match[0];
    }),
    token(/^[a-zA-Z][a-zA-Z_\-0-9]*/,
    function(match) {
      return match[0];
    }),
    token(/^\"(.*)\"/,
    function(match) {
      return match[1];
    }),
    token(/^\'.\'/,
    function(match) {
      return match[0][1].charCodeAt(0);
    }),
    token(/^\'..\'/,
    function(match) {
      return (match[0][1].charCodeAt(0) << 16) + match[0][2].charCodeAt(0);
    })
  ];

  matchArg = function(src) {
    var i, len, matcher, res;
    for (i = 0, len = argMatchers.length; i < len; i++) {
      matcher = argMatchers[i];
      if ((res = matcher(src))) {
        return res;
      }
    }
    return false;
  };

  global.Parser = {
    parse: function(src) {
      var line, lineNr, lines, match, prevlength, res;
      lines = [];
      lineNr = 0;
      line = {};
      prevlength = 0;
      while (src.length !== prevlength) {
        prevlength = src.length;
        if ((res = matchLabel(src))) {
          src = res[0];
          line.label = res[1];
          line.opcode = "nop";
        }
        if (match = src.match(/^[ \t]+/)) {
          src = src.slice(match[0].length);
        }
        if ((res = matchOpcode(src))) {
          src = res[0];
          line.opcode = res[1];
          line.args = [];
          while (src[0] !== "\n") {
            if (!(match = src.match(/^[ \t]+/))) {
              break;
            }
            src = src.slice(match[0].length);
            if (!(res = matchArg(src))) {
              break;
            }
            src = res[0];
            line.args.push(res[1]);
          }
        }
        if (src[0] === ";") {
          src = src.slice(1);
          if (match = src.match(/^[ \t]+/)) {
            src = src.slice(match[0].length);
          }
          if (match = src.match(/^@([\w]*)/)) {
            src = src.slice(match[0].length);
            line.hint = {
              label: match[1]
            };
          }
          src = src.slice(src.indexOf("\n"));
        }
        if (line.opcode != null) {
          if (line.hint == null) {
            line.hint = {};
          }
          line.lineNr = lineNr;
          lines.push(line);
          line = {};
        }
        if (src[0] === "\n") {
          lineNr++;
          src = src.slice(1);
        } else if (src[0] !== void 0) {
          throw new Error(`Unexpected input ${src}`);
        }
      }
      return lines;
    }
  };

}).call(this);

//# sourceMappingURL=parser.js.map
